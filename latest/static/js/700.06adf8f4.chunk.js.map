{"version":3,"file":"static/js/700.06adf8f4.chunk.js","mappings":"mPAWM,MAAOA,UAA4BC,EAAAA,EACvCC,WAAAA,CAAAC,GAcC,IAAAC,EAAA,IAdW,iBACVC,EAAgB,MAChBC,EAAK,KACLC,EAAI,UACJC,EAAS,OACTC,EAAM,KACNC,GAQDP,EACCQ,MACEL,EAAMM,cACJ,2DACF,CACEN,QACAO,aAAc,IACRP,EAAMO,cAAgB,GACR,QAAlBT,EAAAE,EAAMO,oBAAY,IAAAT,GAAlBA,EAAoBU,OAAS,GAAK,GAClC,yBACAJ,GAAQ,CACN,uBACGA,EAAKK,IAAKC,GAAG,OAAAC,QAAYC,EAAAA,EAAAA,GAAOF,MACpC,aAAAC,OACYR,GAAM,WAAAQ,OACRV,GAAI,wBAAAU,OACSZ,GAAgB,iBAAAY,OACvBT,IACjBW,OACFC,KAAM,uBAGZ,EAOI,MAAOC,UAA6CpB,EAAAA,EACxDC,WAAAA,CAAAoB,GAAyD,IAA7C,OAAEC,EAAM,IAAEP,GAAmCM,EACvDX,MACE,6EACA,CACEE,aAAc,CAAC,gBAADI,QACIC,EAAAA,EAAAA,GAAOF,IAAI,aAAAC,QACdO,EAAAA,EAAAA,GAAUD,KAEzBH,KAAM,wCAGZ,EAQI,MAAOK,UAA0CxB,EAAAA,EACrDC,WAAAA,CAAAwB,GAA4D,IAAhD,OAAEjB,EAAM,GAAEkB,GAAsCD,EAC1Df,MACE,yEACA,CACEE,aAAc,CAAC,qBAADI,OACSU,GAAE,kCAAAV,OACWR,IAEpCW,KAAM,qCAGZ,E,iKC9DF,MAAMQ,EAAW,mCA0CX,SAAUC,EAIdC,GAEA,MAAM,IAAEC,EAAG,UAAEC,EAAS,KAAEC,GAASH,EAEjC,IAAII,EAAUH,EAAI,GAClB,GAAIC,EAAW,CACb,MAAMG,GAAOC,EAAAA,EAAAA,IAAW,CAAEL,MAAKE,OAAMb,KAAMY,IAC3C,IAAKG,EAAM,MAAM,IAAIE,EAAAA,GAAsBL,EAAW,CAAEJ,aACxDM,EAAUC,CACZ,CAEA,GAAqB,UAAjBD,EAAQI,KACV,MAAM,IAAID,EAAAA,QAAsBE,EAAW,CAAEX,aAE/C,MAAMY,GAAaC,EAAAA,EAAAA,GAAcP,GAC3BQ,GAAYC,EAAAA,EAAAA,GAAmBH,GAErC,IAAIjC,EAAY,KAChB,GAAI0B,GAAQA,EAAKnB,OAAS,EAAG,CAC3B,IAAKoB,EAAQU,OACX,MAAM,IAAIC,EAAAA,GAA4BX,EAAQd,KAAM,CAAEQ,aACxDrB,GAAOuC,EAAAA,EAAAA,GAAoBZ,EAAQU,OAAQX,EAC7C,CACA,OAAOc,EAAAA,EAAAA,IAAU,CAACL,EAAWnC,GAC/B,CC3EA,MAAMqB,EAAW,sCCRV,MAAMoB,EAAuB,uBAE7BC,eAAeC,EAAyBpB,GAM7C,MAAM,KAAEvB,EAAI,YAAE4C,GAAgBrB,GAG5BG,MAAOmB,ICgCL,SACJtB,GAEA,MAAM,IAAEC,EAAG,KAAExB,GAASuB,EAChBY,GAAYW,EAAAA,EAAAA,IAAM9C,EAAM,EAAG,GAC3B+C,EAAcvB,EAAIwB,KACrBC,GACY,aAAXA,EAAElB,MACFI,KAAcC,EAAAA,EAAAA,IAAmBF,EAAAA,EAAAA,GAAce,KAEnD,IAAKF,EACH,MAAM,IAAIG,EAAAA,GAAkCf,EAAW,CACrDd,SAAU,sCAEd,MAAO,CACL8B,aAAeJ,EAAiClC,KAChDa,KAAO,WAAYqB,GACnBA,EAAYV,QACZU,EAAYV,OAAO9B,OAAS,GACxB6C,EAAAA,EAAAA,GAAoBL,EAAYV,QAAQS,EAAAA,EAAAA,IAAM9C,EAAM,SACpDgC,EAER,CDrDMqB,CAAmB,CAAE7B,IAAK8B,EAAAA,GAAiBtD,SAEzCuD,EAAsB,GACtBC,EAAmB,GAezB,aAdMC,QAAQC,IACZb,EAAQrC,IAAIkC,MAAOiB,EAAOC,KACxB,IACEJ,EAAUI,GAAKD,EAAMxD,KAAK0D,SAASpB,SACzBE,EAAyB,CAAE3C,KAAM2D,EAAM3D,KAAM4C,sBAC7CA,EAAYe,GACtBJ,EAASK,IAAK,CAChB,CAAE,MAAOE,GACPP,EAASK,IAAK,EACdJ,EAAUI,GAaG,sBADAG,EAZcD,GAavBjD,MAA+BkD,EAAMC,OACtC1C,EAAkB,CACvBE,IAAK8B,EAAAA,GACL7B,UAAW,YACXC,KAAM,CAACqC,EAAMC,OAAQD,EAAM1D,gBAExBiB,EAAkB,CACvBE,IAAK,CAACyC,EAAAA,IACNxC,UAAW,QACXC,KAAM,CAAC,iBAAkBqC,EAAQA,EAAM1D,aAAe0D,EAAMG,UArB1D,CAWN,IAAqBH,KDiBf,SAIJxC,GAEA,MAAM,IAAEC,EAAG,aAAE2B,EAAY,OAAEnC,GACzBO,EAEF,IAAII,EAAUH,EAAI,GAClB,GAAI2B,EAAc,CAChB,MAAMvB,GAAOC,EAAAA,EAAAA,IAAW,CAAEL,MAAKX,KAAMsC,IACrC,IAAKvB,EAAM,MAAM,IAAIuC,EAAAA,GAAyBhB,EAAc,CAAE9B,SAAQA,IACtEM,EAAUC,CACZ,CAEA,GAAqB,aAAjBD,EAAQI,KACV,MAAM,IAAIoC,EAAAA,QAAyBnC,EAAW,CAAEX,SAAQA,IAE1D,IAAKM,EAAQyC,QACX,MAAM,IAAIC,EAAAA,GAAgC1C,EAAQd,KAAM,CAAEQ,SAAQA,IAEpE,MAAMiD,EAAS,MACb,GAA+B,IAA3B3C,EAAQyC,QAAQ7D,OAAc,MAAO,GACzC,GAA+B,IAA3BoB,EAAQyC,QAAQ7D,OAAc,MAAO,CAACS,GAC1C,GAAIuD,MAAMC,QAAQxD,GAAS,OAAOA,EAClC,MAAM,IAAIyD,EAAAA,GAAkBzD,EAC7B,EALc,GAOf,OAAOuB,EAAAA,EAAAA,GAAoBZ,EAAQyC,QAASE,EAC9C,CCtDSI,CAAqB,CAC1BlD,IAAK8B,EAAAA,GACLH,aAAc,QACdnC,OAAQ,CAACuC,EAAUC,IAEvB,CEhBO,MAAMmB,EAA0B,aAC1BC,EAAwB,CACnC/D,KAAM,iBACNkB,KAAM,QACNM,OAAQ,CACN,CACExB,KAAM,SACNkB,KAAM,WAER,CACElB,KAAM,OACNkB,KAAM,YAER,CACElB,KAAM,WACNkB,KAAM,SAER,CACElB,KAAM,mBACNkB,KAAM,UAER,CACElB,KAAM,YACNkB,KAAM,WAOLW,eAAemC,EACpBC,EAAgClF,GAS/B,IARD,YACEmF,EAAW,SACXC,EAAQ,KACRhF,EAAI,GACJoB,GAIDxB,EAED,MAAM,KAAE8B,IAASuD,EAAAA,EAAAA,GAAkB,CACjCjF,OACAwB,IAAK,CAACoD,MAED1E,EAAQC,EAAM+E,EAAUpF,EAAkBG,GAAayB,GAExD,SAAEyD,GAAaL,EACfM,EACJD,GAAyC,oBAAd,OAARA,QAAQ,IAARA,OAAQ,EAARA,EAAUE,SACzBF,EAASE,QACTzC,EAEN,IACE,IC1EE,SAAyB0C,EAAYC,GACzC,KAAKC,EAAAA,EAAAA,GAAUF,EAAG,CAAEG,QAAQ,IAC1B,MAAM,IAAIC,EAAAA,EAAoB,CAAEC,QAASL,IAC3C,KAAKE,EAAAA,EAAAA,GAAUD,EAAG,CAAEE,QAAQ,IAC1B,MAAM,IAAIC,EAAAA,EAAoB,CAAEC,QAASJ,IAC3C,OAAOD,EAAEM,gBAAkBL,EAAEK,aAC/B,CDoESC,CAAezE,EAAIlB,GACtB,MAAM,IAAIgB,EAAkC,CAAEhB,SAAQkB,OAExD,MAAMJ,EAASb,EAAK0D,SAASpB,SACnBE,EAAyB,CAC7B3C,KAAMkF,EACNtC,YAAawC,UAETA,EAAa,CAAEpF,KAAMkF,EAAUhF,SAAQC,UAEzCH,KAAM8F,SAAgBC,EAAAA,EAAAA,GAAKjB,EAAQ,CACzCC,cACAC,WACAhF,MAAMU,EAAAA,EAAAA,IAAO,CACXZ,GACAyC,EAAAA,EAAAA,GACE,CAAC,CAAER,KAAM,SAAW,CAAEA,KAAM,UAC5B,CAACf,EAAQf,MAGbmB,OAGF,OAAO0E,CACT,CAAE,MAAOhC,GACP,MAAM,IAAIrE,EAAoB,CAC5BK,mBACAC,MAAO+D,EACP9D,OACAC,YACAC,SACAC,QAEJ,CACF,CAeOuC,eAAeE,EAAW7B,GAIT,IAJU,KAChCf,EAAI,OACJE,EAAM,KACNC,GACsBY,EAClBgD,EAAQ,IAAIiC,MAAM,8BAEtB,IAAK,IAAIpC,EAAI,EAAGA,EAAIzD,EAAKI,OAAQqD,IAAK,CACpC,MAAMnD,EAAMN,EAAKyD,GACXqC,EAASxF,EAAIoD,SAAS,UAAY,MAAQ,OAC1CqC,EAAkB,SAAXD,EAAoB,CAAEjG,OAAME,eAAW8B,EAC9CmE,EACO,SAAXF,EAAoB,CAAE,eAAgB,oBAAuB,CAAC,EAEhE,IAAI,IAAAG,EACF,MAAMC,QAAiBC,MACrB7F,EAAI8F,QAAQ,WAAYrG,EAAO0F,eAAeW,QAAQ,SAAUvG,GAChE,CACEkG,KAAMM,KAAKvF,UAAUiF,GACrBC,UACAF,WAIJ,IAAIjF,EASJ,GALEA,EAFoC,QADtCoF,EACEC,EAASF,QAAQM,IAAI,uBAAe,IAAAL,GAApCA,EAAsCM,WAAW,2BAEjCL,EAASM,QAAQ3G,WAEjBqG,EAASO,QAGtBP,EAASQ,GAAI,KAAAC,EAChB/C,EAAQ,IAAIgD,EAAAA,GAAiB,CAC3Bb,OACAc,QAAe,QAANF,EAAA9F,SAAM,IAAA8F,GAANA,EAAQ/C,OACb9C,EAAAA,EAAAA,GAAUD,EAAO+C,OACjBsC,EAASY,WACbd,QAASE,EAASF,QAClBnC,OAAQqC,EAASrC,OACjBvD,QAEF,QACF,CAEA,KAAKyG,EAAAA,EAAAA,GAAMlG,GAAS,CAClB+C,EAAQ,IAAIjD,EAAqC,CAC/CE,SACAP,QAEF,QACF,CAEA,OAAOO,CACT,CAAE,MAAO8C,GACPC,EAAQ,IAAIgD,EAAAA,GAAiB,CAC3Bb,OACAc,QAAUlD,EAAcI,QACxBzD,OAEJ,CACF,CAEA,MAAMsD,CACR,C","sources":["../../../node_modules/viem/errors/ccip.ts","../../../node_modules/viem/utils/abi/encodeErrorResult.ts","../../../node_modules/viem/utils/abi/encodeFunctionResult.ts","../../../node_modules/viem/utils/ens/localBatchGatewayRequest.ts","../../../node_modules/viem/utils/abi/decodeFunctionData.ts","../../../node_modules/viem/utils/ccip.ts","../../../node_modules/viem/utils/address/isAddressEqual.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n        name: 'OffchainLookupError',\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n        name: 'OffchainLookupResponseMalformedError',\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n        name: 'OffchainLookupSenderMismatchError',\n      },\n    )\n  }\n}\n","import type { Abi, ExtractAbiErrors } from 'abitype'\n\nimport {\n  AbiErrorInputsNotFoundError,\n  AbiErrorNotFoundError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeErrorResult'\n\nexport type EncodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  errorName extends ContractErrorName<abi> | undefined = ContractErrorName<abi>,\n  ///\n  hasErrors = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiErrors<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractErrorArgs<\n    abi,\n    errorName extends ContractErrorName<abi>\n      ? errorName\n      : ContractErrorName<abi>\n  >,\n  allErrorNames = ContractErrorName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { errorName?: errorName | allErrorNames | undefined }\n      : { errorName: errorName | allErrorNames }\n    : { errorName?: errorName | allErrorNames | undefined }\n> &\n  (hasErrors extends true ? unknown : never)\n\nexport type EncodeErrorResultReturnType = Hex\n\nexport type EncodeErrorResultErrorType =\n  | GetAbiItemErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | EncodeAbiParametersErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function encodeErrorResult<\n  const abi extends Abi | readonly unknown[],\n  errorName extends ContractErrorName<abi> | undefined = undefined,\n>(\n  parameters: EncodeErrorResultParameters<abi, errorName>,\n): EncodeErrorResultReturnType {\n  const { abi, errorName, args } = parameters as EncodeErrorResultParameters\n\n  let abiItem = abi[0]\n  if (errorName) {\n    const item = getAbiItem({ abi, args, name: errorName })\n    if (!item) throw new AbiErrorNotFoundError(errorName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'error')\n    throw new AbiErrorNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toFunctionSelector(definition)\n\n  let data: Hex = '0x'\n  if (args && args.length > 0) {\n    if (!abiItem.inputs)\n      throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath })\n    data = encodeAbiParameters(abiItem.inputs, args)\n  }\n  return concatHex([signature, data])\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionName,\n  ContractFunctionReturnType,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionResult'\n\nexport type EncodeFunctionResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n  result?:\n    | ContractFunctionReturnType<\n        abi,\n        AbiStateMutability,\n        functionName extends ContractFunctionName<abi>\n          ? functionName\n          : ContractFunctionName<abi>,\n        never // allow all args. required for overloads to work.\n      >\n    | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | undefined }\n      : { functionName: functionName | allFunctionNames }\n    : { functionName?: functionName | allFunctionNames | undefined }\n> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionResultReturnType = Hex\n\nexport type EncodeFunctionResultErrorType =\n  | AbiFunctionOutputsNotFoundError\n  | AbiFunctionNotFoundError\n  | EncodeAbiParametersErrorType\n  | GetAbiItemErrorType\n  | ErrorType\n\nexport function encodeFunctionResult<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionResultParameters<abi, functionName>,\n): EncodeFunctionResultReturnType {\n  const { abi, functionName, result } =\n    parameters as EncodeFunctionResultParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({ abi, name: functionName })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  if (!abiItem.outputs)\n    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath })\n\n  const values = (() => {\n    if (abiItem.outputs.length === 0) return []\n    if (abiItem.outputs.length === 1) return [result]\n    if (Array.isArray(result)) return result\n    throw new InvalidArrayError(result)\n  })()\n\n  return encodeAbiParameters(abiItem.outputs, values)\n}\n","import { batchGatewayAbi } from '../../constants/abis.js'\nimport { solidityError } from '../../constants/solidity.js'\nimport type { Hex } from '../../types/misc.js'\nimport { decodeFunctionData } from '../abi/decodeFunctionData.js'\nimport { encodeErrorResult } from '../abi/encodeErrorResult.js'\nimport { encodeFunctionResult } from '../abi/encodeFunctionResult.js'\nimport type {\n  CcipRequestErrorType,\n  CcipRequestParameters,\n  CcipRequestReturnType,\n} from '../ccip.js'\n\nexport const localBatchGatewayUrl = 'x-batch-gateway:true'\n\nexport async function localBatchGatewayRequest(parameters: {\n  data: Hex\n  ccipRequest: (\n    parameters: CcipRequestParameters,\n  ) => Promise<CcipRequestReturnType>\n}): Promise<Hex> {\n  const { data, ccipRequest } = parameters\n\n  const {\n    args: [queries],\n  } = decodeFunctionData({ abi: batchGatewayAbi, data })\n\n  const failures: boolean[] = []\n  const responses: Hex[] = []\n  await Promise.all(\n    queries.map(async (query, i) => {\n      try {\n        responses[i] = query.urls.includes(localBatchGatewayUrl)\n          ? await localBatchGatewayRequest({ data: query.data, ccipRequest })\n          : await ccipRequest(query)\n        failures[i] = false\n      } catch (err) {\n        failures[i] = true\n        responses[i] = encodeError(err as CcipRequestErrorType)\n      }\n    }),\n  )\n\n  return encodeFunctionResult({\n    abi: batchGatewayAbi,\n    functionName: 'query',\n    result: [failures, responses],\n  })\n}\n\nfunction encodeError(error: CcipRequestErrorType): Hex {\n  if (error.name === 'HttpRequestError' && error.status)\n    return encodeErrorResult({\n      abi: batchGatewayAbi,\n      errorName: 'HttpError',\n      args: [error.status, error.shortMessage],\n    })\n  return encodeErrorResult({\n    abi: [solidityError],\n    errorName: 'Error',\n    args: ['shortMessage' in error ? error.shortMessage : error.message],\n  })\n}\n","import type { Abi, AbiStateMutability } from 'abitype'\n\nimport { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: abi\n  data: Hex\n}\n\nexport type DecodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allFunctionNames extends\n    ContractFunctionName<abi> = ContractFunctionName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [functionName in allFunctionNames]: {\n          args: ContractFunctionArgs<abi, AbiStateMutability, functionName>\n          functionName: functionName\n        }\n      }[allFunctionNames]\n    >\n  : {\n      args: readonly unknown[] | undefined\n      functionName: string\n    }\n\nexport type DecodeFunctionDataErrorType =\n  | AbiFunctionSignatureNotFoundError\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | SliceErrorType\n  | ErrorType\n\nexport function decodeFunctionData<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeFunctionDataParameters<abi>,\n) {\n  const { abi, data } = parameters as DecodeFunctionDataParameters\n  const signature = slice(data, 0, 4)\n  const description = abi.find(\n    (x) =>\n      x.type === 'function' &&\n      signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!description)\n    throw new AbiFunctionSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeFunctionData',\n    })\n  return {\n    functionName: (description as { name: string }).name,\n    args: ('inputs' in description &&\n    description.inputs &&\n    description.inputs.length > 0\n      ? decodeAbiParameters(description.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n  } as DecodeFunctionDataReturnType<abi>\n}\n","import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport {\n  localBatchGatewayRequest,\n  localBatchGatewayUrl,\n} from './ens/localBatchGatewayRequest.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = urls.includes(localBatchGatewayUrl)\n      ? await localBatchGatewayRequest({\n          data: callData,\n          ccipRequest: ccipRequest_,\n        })\n      : await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers: HeadersInit =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender.toLowerCase()).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n"],"names":["OffchainLookupError","BaseError","constructor","_ref","_cause$metaMessages","callbackSelector","cause","data","extraData","sender","urls","super","shortMessage","metaMessages","length","map","url","concat","getUrl","flat","name","OffchainLookupResponseMalformedError","_ref2","result","stringify","OffchainLookupSenderMismatchError","_ref3","to","docsPath","encodeErrorResult","parameters","abi","errorName","args","abiItem","item","getAbiItem","AbiErrorNotFoundError","type","undefined","definition","formatAbiItem","signature","toFunctionSelector","inputs","AbiErrorInputsNotFoundError","encodeAbiParameters","concatHex","localBatchGatewayUrl","async","localBatchGatewayRequest","ccipRequest","queries","slice","description","find","x","AbiFunctionSignatureNotFoundError","functionName","decodeAbiParameters","decodeFunctionData","batchGatewayAbi","failures","responses","Promise","all","query","i","includes","err","error","status","solidityError","message","AbiFunctionNotFoundError","outputs","AbiFunctionOutputsNotFoundError","values","Array","isArray","InvalidArrayError","encodeFunctionResult","offchainLookupSignature","offchainLookupAbiItem","offchainLookup","client","blockNumber","blockTag","decodeErrorResult","callData","ccipRead","ccipRequest_","request","a","b","isAddress","strict","InvalidAddressError","address","toLowerCase","isAddressEqual","data_","call","Error","method","body","headers","_response$headers$get","response","fetch","replace","JSON","get","startsWith","json","text","ok","_result","HttpRequestError","details","statusText","isHex"],"sourceRoot":""}